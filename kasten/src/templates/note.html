<!-- kasten/src/templates/note.html -->
{% extends "base.html" %}

{% block title %}{{ note.id }} - Kasten{% endblock %}

{% block content %}
<nav class="nav-bar">
    <button class="nav-btn" onclick="history.back()" title="Back">&#8592;</button>
    <a href="javascript:void(0)" class="btn btn-primary" onclick="pushToWorkspace()">Push to Workspace</a>
    <button class="nav-btn" onclick="history.forward()" title="Forward">&#8594;</button>
</nav>

{% if source %}
<section class="source-header" id="source-header">
    <div class="source-title-row">
        <div class="source-info">
            <span class="source-label">Source:</span>
            <span class="source-title">{{ source.title or 'Untitled' }}</span>
        </div>
        <button class="source-toggle" onclick="toggleSource()" id="source-toggle">[+]</button>
    </div>
    <div class="source-meta">{{ source.domain }} Â· {{ source.archived_at.strftime('%b %d') if source.archived_at else '' }}</div>
    <div class="source-details" id="source-details" style="display: none;">
        {% if source.description %}
        <p class="source-description">{{ source.description }}</p>
        {% endif %}
        <a href="{{ source.url }}" target="_blank" class="source-link">Open original</a>
    </div>
</section>
{% endif %}

<article class="note-content">
{{ content | safe }}
</article>

<div class="graph-container">
    <svg id="note-graph" width="300" height="200"></svg>
</div>
{% endblock %}

{% block scripts %}
<script>
const noteId = "{{ note.id }}";
const parent = {{ parent | tojson }};
const children = {{ children | tojson }};
const siblings = {{ siblings | tojson }};
const canvasUrl = "{{ canvas_url }}";

function toggleSource() {
    const details = document.getElementById('source-details');
    const toggle = document.getElementById('source-toggle');
    if (details.style.display === 'none') {
        details.style.display = 'block';
        toggle.textContent = '[-]';
    } else {
        details.style.display = 'none';
        toggle.textContent = '[+]';
    }
}

function pushToWorkspace() {
    fetch('/api/notes/{{ note.id }}')
        .then(r => r.json())
        .then(note => {
            return fetch(canvasUrl + '/api/workspace/notes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    km_note_id: note.id,
                    content: note.content
                })
            });
        })
        .then(r => {
            if (r.ok) alert('Pushed to workspace!');
            else alert('Failed to push');
        })
        .catch(() => alert('Failed to connect to Canvas'));
}

// Navigation graph showing parent hierarchy
(function() {
    const svg = document.getElementById('note-graph');
    const nodeRadius = 15;
    const currentRadius = 18;

    function drawLine(x1, y1, x2, y2) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', '#000');
        svg.appendChild(line);
    }

    function createNode(x, y, note, isCurrent) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', isCurrent ? currentRadius : nodeRadius);
        circle.setAttribute('fill', isCurrent ? '#000' : '#fff');
        circle.setAttribute('stroke', '#000');
        circle.setAttribute('stroke-width', '2');
        if (!isCurrent) {
            circle.style.cursor = 'pointer';
            circle.onclick = () => window.location.href = '/note/' + note.id;
            circle.onmouseover = () => circle.setAttribute('fill', '#f5f5f5');
            circle.onmouseout = () => circle.setAttribute('fill', '#fff');
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            title.textContent = note.id + ': ' + note.title;
            circle.appendChild(title);
        }
        svg.appendChild(circle);
        return circle;
    }

    function addLabel(x, y, text) {
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', y);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', '10');
        label.setAttribute('font-family', 'monospace');
        label.textContent = text;
        svg.appendChild(label);
    }

    const hasSiblings = siblings.length > 0;
    const hasParent = parent !== null;

    if (hasParent && hasSiblings) {
        // BRANCH VIEW: Show parent with current as one of multiple branches
        // Layout: parent on left, branches forking to the right
        const parentX = 50, parentY = 80;
        const forkX = 100;
        const branchX = 200;
        const branchSpacing = 35;

        // All branches = siblings + current, sorted by position
        const allBranches = [...siblings, {id: noteId, title: '', isCurrent: true}];
        const currentIndex = allBranches.findIndex(b => b.isCurrent);

        // Draw parent
        createNode(parentX, parentY, parent, false);

        // Draw main line from parent to fork point
        drawLine(parentX + nodeRadius, parentY, forkX, parentY);

        // Draw vertical spine at fork point
        const topY = parentY - (currentIndex * branchSpacing);
        const bottomY = topY + ((allBranches.length - 1) * branchSpacing);
        drawLine(forkX, topY, forkX, bottomY);

        // Draw branches
        allBranches.forEach((branch, i) => {
            const y = topY + (i * branchSpacing);
            drawLine(forkX, y, branchX, y);
            createNode(branchX, y, branch, branch.isCurrent);
            if (branch.isCurrent) {
                addLabel(branchX, y + currentRadius + 12, noteId);
            }
        });

        // Draw children of current (if any) further right
        if (children.length > 0) {
            const currentY = topY + (currentIndex * branchSpacing);
            const childX = 270;
            drawLine(branchX + currentRadius, currentY, childX - nodeRadius, currentY);
            createNode(childX, currentY, children[0], false);
        }
    } else {
        // STANDARD VIEW: parent -> current -> children
        const parentX = 50, currentX = 150, childX = 250;
        const mainY = 50;
        const branchStartY = 95, branchSpacing = 40;

        // Draw current node
        createNode(currentX, mainY, {id: noteId}, true);
        addLabel(currentX, mainY + currentRadius + 12, noteId);

        // Draw parent if exists
        if (parent) {
            drawLine(parentX + nodeRadius, mainY, currentX - currentRadius, mainY);
            createNode(parentX, mainY, parent, false);
        }

        // Draw first child as "next"
        if (children.length > 0) {
            drawLine(currentX + currentRadius, mainY, childX - nodeRadius, mainY);
            createNode(childX, mainY, children[0], false);
        }

        // Draw additional children as branches
        const forkX = 200;
        children.slice(1, 3).forEach((child, i) => {
            const y = branchStartY + (i * branchSpacing);
            drawLine(forkX, mainY, childX, y);
            createNode(childX, y, child, false);
        });

        // "+N more" indicator
        if (children.length > 3) {
            addLabel(childX, branchStartY + (2 * branchSpacing) + 20, '+' + (children.length - 3) + ' more');
        }
    }
})();
</script>
{% endblock %}
