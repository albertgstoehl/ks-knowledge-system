{% extends "base.html" %}

{% block title %}Draft - Canvas{% endblock %}

{% block extra_styles %}
.draft-container {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 120px);
}
.canvas-editor {
    width: 100%;
    flex: 1;
    padding: 1rem;
    border: 2px solid #000;
    font-family: inherit;
    font-size: 1rem;
    line-height: 1.6;
    resize: none;
}
.canvas-editor:focus {
    outline: none;
    border-color: #000;
}
.status-bar {
    display: flex;
    justify-content: flex-end;
    padding: 0.5rem 0;
}
.modal {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
}
.modal.active { display: flex; align-items: center; justify-content: center; }
.modal-content {
    background: #fff;
    border: 2px solid #000;
    padding: 1.5rem;
    min-width: 400px;
    max-width: 500px;
}
.modal-content h3 { margin-bottom: 1rem; }
.note-preview {
    background: #f5f5f5;
    padding: 0.75rem;
    margin-bottom: 1rem;
    font-size: 0.875rem;
    max-height: 120px;
    overflow: auto;
    white-space: pre-wrap;
}
.form-group { margin-bottom: 1rem; }
.form-group label { display: block; margin-bottom: 0.25rem; }
.form-group input, .form-group select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #000;
    font-family: inherit;
}
.modal-actions { display: flex; gap: 0.5rem; justify-content: flex-end; }
.hint { color: #666; font-size: 0.75rem; margin-left: 1rem; }
{% endblock %}

{% block content %}
<div class="draft-container">
    <div class="status-bar">
        <span class="save-status" id="save-status">Saved</span>
        <span class="hint">### Title ... --- to create note</span>
    </div>
    <textarea
        class="canvas-editor"
        id="canvas-editor"
        placeholder="Start writing... Quotes from bookmark-manager will appear here."
    >{{ content }}</textarea>
</div>

<!-- Note Creation Modal -->
<div class="modal" id="note-modal">
    <div class="modal-content">
        <h3>Create Note</h3>
        <div class="note-preview" id="note-preview"></div>
        <div class="form-group">
            <label for="parent-search">Parent note (search by ID):</label>
            <input type="text" id="parent-search" placeholder="Type to search..." autocomplete="off">
            <select id="parent-select" size="5" style="margin-top:0.5rem;display:none;">
            </select>
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="closeNoteModal()">Cancel</button>
            <button class="btn btn-primary" onclick="createNote()">Create Note</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    const editor = document.getElementById('canvas-editor');
    const status = document.getElementById('save-status');
    let saveTimeout = null;
    let lastSaved = editor.value;

    // Sync with server on load (quotes may have arrived via API)
    fetch('/api/canvas')
        .then(r => r.json())
        .then(data => {
            const serverTime = new Date(data.updated_at).getTime();
            const localTime = parseInt(localStorage.getItem('canvas-draft-time') || '0');

            // Use server content if newer than local cache
            if (serverTime > localTime || !localTime) {
                editor.value = data.content;
                lastSaved = data.content;
                localStorage.setItem('canvas-draft', data.content);
                localStorage.setItem('canvas-draft-time', serverTime.toString());
            }
        })
        .catch(() => {
            // Offline: use localStorage if available
            const cached = localStorage.getItem('canvas-draft');
            if (cached) editor.value = cached;
        });

    function save() {
        const content = editor.value;
        if (content === lastSaved) return;

        status.textContent = 'Saving...';

        // Save to server first, then update localStorage with server timestamp
        fetch('/api/canvas', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: content })
        })
        .then(response => {
            if (response.ok) {
                return response.json();
            } else {
                throw new Error('Save failed');
            }
        })
        .then(data => {
            lastSaved = content;
            status.textContent = 'Saved';
            // Use server timestamp for consistency
            const serverTime = new Date(data.updated_at).getTime();
            localStorage.setItem('canvas-draft', content);
            localStorage.setItem('canvas-draft-time', serverTime.toString());
        })
        .catch(() => {
            // Offline: save to localStorage with current time
            localStorage.setItem('canvas-draft', content);
            localStorage.setItem('canvas-draft-time', Date.now().toString());
            status.textContent = 'Offline (saved locally)';
        });
    }

    editor.addEventListener('input', function() {
        status.textContent = 'Unsaved';
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(save, 300);
    });

    // Save on page leave
    window.addEventListener('beforeunload', save);

    // Note creation
    const kastenUrl = "{{ kasten_url }}";
    let pendingNote = null;

    function detectNoteBlock(text, cursorPos) {
        // Find --- ending at or before cursor
        const beforeCursor = text.substring(0, cursorPos);
        const lastDashes = beforeCursor.lastIndexOf('\n---');
        if (lastDashes === -1) return null;

        // Check if --- is on its own line
        const afterDashes = beforeCursor.substring(lastDashes + 4);
        if (afterDashes.trim() !== '' && afterDashes !== '\n') return null;

        // Find ### before the ---
        const blockText = beforeCursor.substring(0, lastDashes);
        const hashMatch = blockText.match(/\n### ([^\n]+)\n([\s\S]*)$/);
        if (!hashMatch) {
            // Try at start of text (### at very beginning)
            const startMatch = blockText.match(/^### ([^\n]+)\n([\s\S]*)$/);
            if (!startMatch) return null;

            return {
                title: startMatch[1].trim(),
                content: startMatch[2].trim(),
                start: 0,
                end: cursorPos
            };
        }

        // Check if ### is inside a quote block (line before ### starts with >)
        const linesBeforeHash = blockText.substring(0, blockText.lastIndexOf('\n### ')).split('\n');
        const lineBeforeHash = linesBeforeHash[linesBeforeHash.length - 1];
        if (lineBeforeHash && lineBeforeHash.startsWith('>')) return null;

        const startPos = blockText.lastIndexOf('\n### ');
        return {
            title: hashMatch[1].trim(),
            content: hashMatch[2].trim(),
            start: startPos === -1 ? 0 : startPos + 1,
            end: cursorPos
        };
    }

    function showNoteModal(note) {
        pendingNote = note;
        document.getElementById('note-preview').textContent =
            `### ${note.title}\n\n${note.content.substring(0, 200)}${note.content.length > 200 ? '...' : ''}`;
        document.getElementById('parent-search').value = '';
        document.getElementById('parent-select').innerHTML = '';
        document.getElementById('parent-select').style.display = 'none';
        document.getElementById('note-modal').classList.add('active');
        document.getElementById('parent-search').focus();
        loadNotes();
    }

    window.closeNoteModal = function() {
        document.getElementById('note-modal').classList.remove('active');
        pendingNote = null;
    };

    let allNotes = [];
    async function loadNotes() {
        try {
            const resp = await fetch(kastenUrl + '/api/notes');
            allNotes = await resp.json();
        } catch (e) {
            console.error('Failed to load notes:', e);
            allNotes = [];
        }
    }

    document.getElementById('parent-search').addEventListener('input', function(e) {
        const query = e.target.value.toLowerCase();
        const select = document.getElementById('parent-select');

        if (!query) {
            select.style.display = 'none';
            return;
        }

        const matches = allNotes.filter(n => n.id.toLowerCase().includes(query));
        select.innerHTML = '<option value="">No parent (new starting point)</option>' +
            matches.map(n => `<option value="${n.id}">${n.id}: ${n.title}</option>`).join('');
        select.style.display = matches.length > 0 ? 'block' : 'none';
    });

    window.createNote = async function() {
        if (!pendingNote) return;

        const parentSelect = document.getElementById('parent-select');
        const parent = parentSelect.value || null;

        // Parse first source from quotes: > — Title (url)
        let source_id = null;
        const sourceMatch = pendingNote.content.match(/^>\s*—\s*(.+?)\s*\((\S+)\)\s*$/m);

        if (sourceMatch) {
            const [, sourceTitle, sourceUrl] = sourceMatch;
            try {
                const sourceResp = await fetch(kastenUrl + '/api/sources', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: sourceUrl, title: sourceTitle })
                });
                if (sourceResp.ok) {
                    const source = await sourceResp.json();
                    source_id = source.id;
                }
            } catch (e) {
                console.warn('Failed to create source:', e);
            }
        }

        try {
            const resp = await fetch(kastenUrl + '/api/notes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    title: pendingNote.title,
                    content: pendingNote.content,
                    parent: parent,
                    source_id: source_id
                })
            });

            if (resp.ok) {
                const result = await resp.json();
                // Remove the block from editor
                const text = editor.value;
                editor.value = text.substring(0, pendingNote.start) + text.substring(pendingNote.end);
                lastSaved = null; // Force save (null never equals any string)
                save();
                closeNoteModal();
                alert(`Note created: ${result.id}`);
            } else {
                alert('Failed to create note');
            }
        } catch (e) {
            alert('Error: ' + e.message);
        }
    };

    // Detect --- on Enter key
    editor.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            setTimeout(() => {
                const note = detectNoteBlock(editor.value, editor.selectionStart);
                if (note && note.title && note.content) {
                    showNoteModal(note);
                }
            }, 0);
        }
    });
})();
</script>
{% endblock %}
