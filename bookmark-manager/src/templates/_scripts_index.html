<script>
(function() {
    const API_BASE = '/bookmarks';
    const currentView = '{{ view }}';

    // Live expiry countdown timers
    function formatTimeLeft(ms) {
        if (ms <= 0) return 'expired';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days}d ${hours % 24}h`;
        if (hours > 0) return `${hours}h ${minutes % 60}m`;
        if (minutes > 0) return `${minutes}m`;
        return 'expires soon';
    }

    function updateExpiryTimers() {
        const timers = document.querySelectorAll('.expiry-timer');
        const now = Date.now();

        timers.forEach(timer => {
            const expiresAt = new Date(timer.dataset.expires).getTime();
            const timeLeft = expiresAt - now;
            timer.textContent = formatTimeLeft(timeLeft);

            // Add urgency styling
            if (timeLeft < 3600000) { // < 1 hour
                timer.style.color = '#c00';
            } else if (timeLeft < 86400000) { // < 1 day
                timer.style.color = '#000';
            } else {
                timer.style.color = '#666';
            }
        });
    }

    // Update timers every minute
    if (currentView === 'inbox') {
        updateExpiryTimers();
        setInterval(updateExpiryTimers, 60000);
    }

    // YouTube Player variables
    let ytPlayer = null;
    const currentVideoId = '{{ bookmarks[0].video_id if bookmarks and bookmarks[0].video_id else "" }}';
    const currentBookmarkId = {{ bookmarks[0].id if bookmarks else 'null' }};

    // Load YouTube IFrame API if we have a video
    if (currentVideoId && currentView === 'inbox') {
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(tag);
    }

    // Called by YouTube API when ready
    window.onYouTubeIframeAPIReady = function() {
        if (!currentVideoId) return;

        ytPlayer = new YT.Player('yt-player', {
            events: {
                onStateChange: onPlayerStateChange
            }
        });
    };

    // Handle player state changes
    function onPlayerStateChange(event) {
        if (!ytPlayer || !currentBookmarkId) return;

        // PAUSED - auto-save timestamp
        if (event.data === YT.PlayerState.PAUSED) {
            const currentTime = Math.floor(ytPlayer.getCurrentTime());
            autoSaveTimestamp(currentBookmarkId, currentTime);
        }

    }

    // Auto-save timestamp on pause
    async function autoSaveTimestamp(bookmarkId, timestamp) {
        const statusEl = document.getElementById('timestamp-display');
        const indicatorEl = document.getElementById('save-indicator');

        const mins = Math.floor(timestamp / 60);
        const secs = timestamp % 60;
        if (statusEl) statusEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        if (indicatorEl) indicatorEl.textContent = ' Saving...';

        try {
            const res = await fetch(`${API_BASE}/${bookmarkId}/timestamp`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ timestamp: timestamp })
            });
            if (res.ok && indicatorEl) {
                indicatorEl.textContent = ' Saved';
                setTimeout(() => { indicatorEl.textContent = ''; }, 2000);
            }
        } catch (err) {
            console.error('Failed to save timestamp:', err);
            if (indicatorEl) indicatorEl.textContent = ' Failed';
        }
    }

    // Toggle move menu visibility
    window.toggleMoveMenu = function() {
        const menu = document.getElementById('move-menu');
        const backdrop = document.getElementById('move-menu-backdrop');
        menu.classList.toggle('visible');
        if (backdrop) backdrop.classList.toggle('visible');
    };

    // Close move menu
    window.closeMoveMenu = function() {
        const menu = document.getElementById('move-menu');
        const backdrop = document.getElementById('move-menu-backdrop');
        if (menu) menu.classList.remove('visible');
        if (backdrop) backdrop.classList.remove('visible');
    };

    // Close move menu when clicking outside (desktop)
    document.addEventListener('click', function(e) {
        const menu = document.getElementById('move-menu');
        const container = e.target.closest('.move-menu-container');
        const backdrop = e.target.closest('.move-menu-backdrop');
        if (!container && !backdrop && menu) {
            closeMoveMenu();
        }
    });

    // Read more toggle for long descriptions
    window.toggleDescription = function() {
        const desc = document.getElementById('description');
        const btn = document.getElementById('read-more-btn');
        if (desc && btn) {
            desc.classList.toggle('expanded');
            btn.textContent = desc.classList.contains('expanded') ? 'Show less' : 'Read more';
        }
    };

    // Show read more button and gradient if description overflows
    function initReadMore() {
        const desc = document.getElementById('description');
        const btn = document.getElementById('read-more-btn');
        if (desc && btn) {
            if (desc.scrollHeight > desc.clientHeight) {
                desc.classList.add('overflow');
                btn.style.display = 'block';
            }
        }
    }
    document.addEventListener('DOMContentLoaded', initReadMore);

    // Move to thesis
    window.moveToThesis = async function(id) {
        try {
            await fetch(`${API_BASE}/${id}/thesis`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ is_thesis: true })
            });
            window.location.reload();
        } catch (err) {
            console.error('Failed to mark as thesis:', err);
        }
    };

    // Pin item
    window.pinItem = async function(id) {
        try {
            await fetch(`${API_BASE}/${id}/pin`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pinned: true })
            });
            window.location.reload();
        } catch (err) {
            console.error('Failed to pin:', err);
        }
    };

    // Delete item
    window.deleteItem = async function(id) {
        if (!confirm('Delete this bookmark?')) return;
        try {
            await fetch(`${API_BASE}/${id}`, { method: 'DELETE' });
            window.location.reload();
        } catch (err) {
            console.error('Failed to delete:', err);
        }
    };

    // Retry scrape with real-time progress via SSE
    window.retryScrape = function(id) {
        const btn = document.getElementById('retry-btn');
        if (btn) {
            btn.textContent = 'Starting...';
            btn.disabled = true;
        }

        // Use fetch with streaming to read SSE
        fetch(`${API_BASE}/${id}/retry`, { method: 'POST' })
            .then(response => {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                function read() {
                    reader.read().then(({ done, value }) => {
                        if (done) {
                            if (btn) btn.textContent = 'Done!';
                            setTimeout(() => window.location.reload(), 500);
                            return;
                        }

                        const text = decoder.decode(value);
                        const lines = text.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const msg = line.slice(6);
                                if (msg === 'done') {
                                    if (btn) btn.textContent = 'Done!';
                                    setTimeout(() => window.location.reload(), 500);
                                    return;
                                } else if (msg.startsWith('error:')) {
                                    alert('Retry failed: ' + msg.slice(6));
                                    if (btn) {
                                        btn.textContent = 'Retry';
                                        btn.disabled = false;
                                    }
                                    return;
                                } else if (btn) {
                                    btn.textContent = msg;
                                }
                            }
                        }
                        read();
                    });
                }
                read();
            })
            .catch(err => {
                console.error('Failed to retry:', err);
                alert('Retry failed: ' + err.message);
                if (btn) {
                    btn.textContent = 'Retry';
                    btn.disabled = false;
                }
            });
    };

    // Restore item (move back to inbox)
    window.restoreItem = async function(id) {
        try {
            await fetch(`${API_BASE}/${id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ state: 'inbox' })
            });
            window.location.reload();
        } catch (err) {
            console.error('Failed to restore:', err);
        }
    };

    // Click handler for thesis view
    const bookmarkList = document.getElementById('bookmark-list');
    if (bookmarkList && currentView === 'thesis') {
        bookmarkList.addEventListener('click', function(e) {
            const item = e.target.closest('.list__item');
            if (item) selectThesisItem(item);
        });
    }

    // Click handler for pins view
    if (bookmarkList && currentView === 'pins') {
        bookmarkList.addEventListener('click', function(e) {
            const item = e.target.closest('.list__item');
            if (item) selectPinsItem(item);
        });
    }

    function selectThesisItem(item) {
        document.querySelectorAll('.list__item').forEach(el => el.classList.remove('list__item--selected'));
        item.classList.add('list__item--selected');

        const panel = document.getElementById('detail-panel');
        const data = item.dataset;

        panel.innerHTML = `
            <button class="btn back-btn" data-action="close">Back</button>
            <h2 class="detail-title"><span class="label">[DOC]</span> ${data.title}</h2>
            <div class="detail-domain">${getDomain(data.url)}</div>
            <div class="detail-actions">
                <a href="${data.url}" target="_blank" class="btn btn-primary">Open</a>
                <button class="btn" data-action="cite" data-id="${data.id}">Cite</button>
                <button class="btn" data-action="remove-thesis" data-id="${data.id}">Remove from Thesis</button>
                <button class="btn btn-danger" data-action="delete" data-id="${data.id}">Delete</button>
            </div>
        `;
        panel.classList.add('active');
    }

    function selectPinsItem(item) {
        document.querySelectorAll('.list__item').forEach(el => el.classList.remove('list__item--selected'));
        item.classList.add('list__item--selected');

        const panel = document.getElementById('detail-panel');
        const data = item.dataset;

        panel.innerHTML = `
            <button class="btn back-btn" data-action="close">Back</button>
            <h2 class="detail-title"><span class="label">[PIN]</span> ${data.title}</h2>
            <div class="detail-domain">${getDomain(data.url)}</div>
            <div class="detail-actions">
                <a href="${data.url}" target="_blank" class="btn btn-primary">Open</a>
                <button class="btn" data-action="cite" data-id="${data.id}">Cite</button>
                <button class="btn" data-action="unpin" data-id="${data.id}">Unpin</button>
                <button class="btn btn-danger" data-action="delete" data-id="${data.id}">Delete</button>
            </div>
        `;
        panel.classList.add('active');
    }

    // Remove from thesis
    window.removeFromThesis = async function(id) {
        try {
            await fetch(`${API_BASE}/${id}/thesis`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ is_thesis: false })
            });
            window.location.reload();
        } catch (err) {
            console.error('Failed to remove from thesis:', err);
        }
    };

    // Unpin item
    window.unpinItem = async function(id) {
        try {
            await fetch(`${API_BASE}/${id}/pin`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pinned: false })
            });
            window.location.reload();
        } catch (err) {
            console.error('Failed to unpin:', err);
        }
    };

    window.closeDetail = function() {
        document.getElementById('detail-panel').classList.remove('active');
        document.querySelectorAll('.list__item').forEach(el => el.classList.remove('list__item--selected'));
    };

    // Event delegation for detail panel buttons (fixes iPad touch issues)
    const detailPanel = document.getElementById('detail-panel');
    if (detailPanel) {
        detailPanel.addEventListener('click', function(e) {
            const btn = e.target.closest('[data-action]');
            if (!btn) return;

            const action = btn.dataset.action;
            const id = btn.dataset.id;

            switch(action) {
                case 'close': closeDetail(); break;
                case 'cite': openCiteModal(id); break;
                case 'delete': deleteItem(id); break;
                case 'unpin': unpinItem(id); break;
                case 'remove-thesis': removeFromThesis(id); break;
            }
        });
    }

    function getDomain(url) {
        try {
            return new URL(url).hostname.replace('www.', '');
        } catch {
            return url;
        }
    }

    // Next up click handlers
    document.querySelectorAll('.next-up__item').forEach(item => {
        item.addEventListener('click', function() {
            const id = this.dataset.id;
            // For now, just reload with this item (would need backend support for proper ordering)
            window.location.reload();
        });
    });

    // Mobile focus view for inbox
    if (currentView === 'inbox' && window.innerWidth <= 768) {
        const currentItem = document.querySelector('.current-item');
        const actionPanel = document.querySelector('.action-panel');

        if (currentItem && actionPanel) {
            // On mobile, clicking current item shows action panel overlay
            currentItem.addEventListener('click', function(e) {
                if (e.target.closest('.next-up__item')) return;
                actionPanel.classList.toggle('mobile-visible');
            });
        }
    }

    // Cite modal (reuse existing)
    let currentCiteBookmarkId = null;

    window.openCiteModal = async function(bookmarkId) {
        currentCiteBookmarkId = bookmarkId;
        const modal = document.getElementById('cite-modal');
        const contentDiv = document.getElementById('cite-source-content');
        const citeBtn = document.getElementById('cite-btn');

        if (!modal) return;

        modal.style.display = 'flex';
        contentDiv.innerHTML = 'Loading content...';
        citeBtn.disabled = true;

        try {
            const res = await fetch(`${API_BASE}/${bookmarkId}/content`);
            const data = await res.json();
            contentDiv.innerHTML = data.content || 'No content available';
        } catch (err) {
            contentDiv.innerHTML = 'Failed to load content';
            console.error(err);
        }
    };

    window.closeCiteModal = function() {
        const modal = document.getElementById('cite-modal');
        if (modal) modal.style.display = 'none';
        currentCiteBookmarkId = null;
    };

    window.citeSelection = async function() {
        const selection = document.getSelection();
        const quote = selection.toString().trim();

        if (!quote || !currentCiteBookmarkId) return;

        const citeBtn = document.getElementById('cite-btn');
        citeBtn.disabled = true;
        citeBtn.textContent = 'Sending...';

        try {
            const res = await fetch('/canvas/quotes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    bookmark_id: currentCiteBookmarkId,
                    quote: quote
                })
            });

            if (res.ok) {
                citeBtn.textContent = 'Cited';
                setTimeout(() => {
                    closeCiteModal();
                    citeBtn.textContent = 'Cite this';
                }, 1000);
            } else {
                const error = await res.json();
                alert(`Failed: ${error.detail}`);
                citeBtn.textContent = 'Cite this';
                citeBtn.disabled = false;
            }
        } catch (err) {
            alert('Failed to cite');
            console.error(err);
            citeBtn.textContent = 'Cite this';
            citeBtn.disabled = false;
        }
    };

    // Selection change handler for cite button
    document.addEventListener('selectionchange', () => {
        const modal = document.getElementById('cite-modal');
        const contentDiv = document.getElementById('cite-source-content');
        const citeBtn = document.getElementById('cite-btn');

        if (!modal || modal.style.display === 'none') return;

        const selection = document.getSelection();
        const selectedText = selection.toString().trim();

        if (selectedText && selection.anchorNode && contentDiv) {
            const isFromContent = contentDiv.contains(selection.anchorNode);
            citeBtn.disabled = !isFromContent;
        } else {
            citeBtn.disabled = true;
        }
    });
})();
</script>
